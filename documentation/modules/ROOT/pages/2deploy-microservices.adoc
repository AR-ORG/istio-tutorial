= Deploy Microservices
include::_attributes.adoc[]

ifdef::workshop[]
Create an environment variable for your user and log into OpenShift.

[source,bash,subs="+macros,+attributes"]
----
#Example:
export WORKSHOP_USER=1
# update the tutorial to point to istio-tutorial
export TUTORIAL_HOME="/projects/$CHE_WORKSPACE_ID/projects/istio-tutorial"
# login to OpenShift
oc login --insecure-skip-tls-verify=true -u user$WORKSHOP_USER -p openshift {ocpurl}
----
endif::workshop[]

[#deploycustomer]
== Deploy customer

Make sure you are logged in

[source,bash,subs="+macros,+attributes"]
----
oc whoami
----

and you have setup the project/namespace

[source,bash,subs="+macros,+attributes"]
----
oc project tutorial{namespace-suffix}
cd $TUTORIAL_HOME
----

ifndef::workshop[]
Give the tutorial project the required privileges.

[source,bash,subs="+macros,+attributes"]
----
oc adm policy add-scc-to-user privileged -z default -n tutorial{namespace-suffix}
----
endif::workshop[]

=== Deploy Customer 

ifndef::workshop[]
NOTE: You will deploy docker images that were previously built. If you want to build customer visit: xref:2build-microservices.adoc#buildcustomer[Build Customer]
endif::[]

Now let's deploy the customer pod with its sidecar

[source,bash,subs="+macros,+attributes"]
----
oc apply  -f link:{github-repo}/{customer-repo}/kubernetes/Deployment.yml[{customer-repo}/kubernetes/Deployment.yml] -n tutorial{namespace-suffix}
oc create -f link:{github-repo}/{customer-repo}/kubernetes/Service.yml[{customer-repo}/kubernetes/Service.yml] -n tutorial{namespace-suffix}
----

=== Expose customer

Since the `customer` service is the one our users will interact with, let's add an OpenShift Route that exposes that endpoint.

ifndef::workshop[]
[source,bash,subs="+macros,+attributes"]
----
yq w -i -d1 link:{github-repo}/{customer-repo}/kubernetes/Gateway.yml[{customer-repo}/kubernetes/Gateway.yml] 'spec.http[0].match[0].uri.prefix' "/tutorial-$WORKSHOP_USER-customer"

oc create -f link:{github-repo}/{customer-repo}/kubernetes/Gateway.yml[{customer-repo}/kubernetes/Gateway.yml] -n tutorial{namespace-suffix}
or
kubectl create -f link:{github-repo}/{customer-repo}/kubernetes/Gateway.yml[{customer-repo}/kubernetes/Gateway.yml] -n tutorial{namespace-suffix}

oc get pods -w -n tutorial{namespace-suffix}
or
kubectl get pods -w -n tutorial{namespace-suffix}
----
endif::workshop[]

ifdef::workshop[]
[source,bash,subs="+macros,+attributes"]
----
yq w -i -d1 link:{github-repo}/{customer-repo}/kubernetes/Gateway.yml[{customer-repo}/kubernetes/Gateway.yml] 'spec.http[0].match[0].uri.prefix' "/tutorial-$WORKSHOP_USER-customer"

oc create -f link:{github-repo}/{customer-repo}/kubernetes/Gateway.yml[{customer-repo}/kubernetes/Gateway.yml] -n tutorial{namespace-suffix}

oc get pods -w -n tutorial{namespace-suffix}
----
endif::workshop[]

IMPORTANT: If your pod fails with `ImagePullBackOff`, it's possible that your current terminal isn't using the proper Docker Environment. See link:#setup-environment[Setup environment].

Wait until the status is `Running` and there are `2/2` pods in the `Ready` column. To exit, press `Ctrl+C`

Then test the customer endpoint

[source,bash,subs="+macros,+attributes"]
----
curl istio-ingressgateway-istio-system.{appdomain}/{path}
----

You should see the following error because the services `preference` and `recommendation` are not yet deployed.

----
customer => UnknownHostException: preference
----

Also review the logs

[source,bash,subs="+macros,+attributes"]
----
stern customer -c customer
----

You should see a stacktrace containing this cause:

[source,bash,subs="+macros,+attributes"]
----
customer-6fc99b7bfd-5st28 customer Caused by: java.net.UnknownHostException: preference
----

[#deploypreference]
== Deploy Preference

NOTE: You will deploy docker images that were previously built. If you want to build preference visit: xref:2build-microservices.adoc#buildpreference[Build Preference]

Now let's deploy the preference pod with its sidecar

[source,bash,subs="+macros,+attributes"]
----
oc apply -f link:{github-repo}/{preference-repo}/kubernetes/Deployment.yml[{preference-repo}/kubernetes/Deployment.yml] -n tutorial{namespace-suffix}
oc create -f link:{github-repo}/{preference-repo}/kubernetes/Service.yml[{preference-repo}/kubernetes/Service.yml] -n tutorial{namespace-suffix}
----

=== Wait preference to be deployed

[source, bash,subs="+macros,+attributes"]
----
oc get pods -w  -n tutorial{namespace-suffix}
----

Wait until the status is `Running` and there are `2/2` pods in the `Ready` column. To exit, press `Ctrl+C`

[source,bash,subs="+macros,+attributes"]
----
curl istio-ingressgateway-istio-system.{appdomain}/{path}
----

It will respond with an error since the service `recommendation` is not yet deployed.

NOTE: We could make this a bit more resilient in a future iteration of this tutorial

[source,bash,subs="+macros,+attributes"]
----
customer => Error: 503 - preference => UnknownHostException: recommendation
----

and check out the logs

[source,bash,subs="+macros,+attributes"]
----
stern preference -c preference
----

You should see a stacktrace containing this cause:

[source,bash,subs="+macros,+attributes"]
----
preference-v1-898764bdb-hz7s6 preference Caused by: java.net.UnknownHostException: recommendation
----

[#deployrecommendation]
== Deploy Recommendation

NOTE: You will deploy docker images that were previously built. If you want to build recommendation visit: xref:2build-microservices.adoc#buildrecommendation[Build Recommendation]

Now let's deploy the recommendation pod with its sidecar

[source,bash,subs="+macros,+attributes"]
----
oc apply -f link:{github-repo}/{recommendation-repo}/kubernetes/Deployment.yml[{recommendation-repo}/kubernetes/Deployment.yml] -n tutorial{namespace-suffix}
oc create -f link:{github-repo}/{recommendation-repo}/kubernetes/Service.yml[{recommendation-repo}/kubernetes/Service.yml]  -n tutorial{namespace-suffix}
oc get pods -w -n tutorial{namespace-suffix}
----

=== Wait recommendation to be deployed

Wait until the status is `Running` and there are `2/2` pods in the `Ready` column. To exit, press `Ctrl+C`

[source,bash,subs="+macros,+attributes"]
----
curl istio-ingressgateway-istio-system.{appdomain}/{path}
----

it should now return

[source,bash,subs="+macros,+attributes"]
----
customer => preference => recommendation v1 from '99634814-sf4cl': 1
----

and you can monitor the `recommendation` logs with

[source,bash,subs="+macros,+attributes"]
----
stern $(kubectl get pods|grep recommendation-v1|awk '{ print $1 }'|head -1) -c recommendation
or
stern "recommendation-v1-\w" -c recommendation-v1
----


ifndef::workshop[]
[#redeployingcode]
== Updating Redeploying Code

When you wish to change code (e.g. editing the .java files) and wish to "redeploy", simply:

[source,bash]
----
cd {servicename}/java/{quarkus|springboot|vertx}

vi src/main/java/com/redhat/developer/demos/{servicename}/{Servicename}{Controller|Verticle}.java
----

Make your changes, save it and then:

[source,bash]
----
mvn clean package
docker build -t example/{servicename}:v1 .

oc get pods -o jsonpath='{.items[*].metadata.name}' -l app={servicename}
oc get pods -o jsonpath='{.items[*].metadata.name}' -l app={servicename},version=v1
oc delete pod -l app={servicename},version=v1 -n tutorial{namespace-suffix}

----

Why the delete pod?

Based on the Deployment configuration, Kubernetes/OpenShift will recreate the pod, based on the new docker image as it attempts to keep the desired replicas available

[source,bash]
----
oc describe deployment {servicename}  -n tutorial{namespace-suffix}| grep Replicas
----
endif::[]
